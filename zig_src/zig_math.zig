const std = @import("std");

pub const e = @cImport({
    @cInclude("erl_nif.h");
});

export fn add(env: ?*e.ErlNifEnv, argc: c_int, argv: [*c]const e.ERL_NIF_TERM) e.ERL_NIF_TERM {
    if (argc != 2) {
        return e.enif_make_badarg(env);
    }

    var a: c_int = undefined;
    var b: c_int = undefined;
    if (e.enif_get_int(env, argv[0], &a) == 0 or
        e.enif_get_int(env, argv[1], &b) == 0)
    {
        return e.enif_make_badarg(env);
    }

    return e.enif_make_int(env, a + b);
}

// Everything here below is what gets generated by the ERL_NIF_INIT macro in C
// This can probably be aided by comptime instead of manually filling this in
var __exported_nifs__ = [_]e.ErlNifFunc{
    e.ErlNifFunc{
        .name = "add",
        .arity = 2,
        .fptr = add,
        .flags = 0,
    },
};

const entry = e.ErlNifEntry{
    .major = 2,
    .minor = 16,
    .name = "Elixir.ZigNifExample",
    .num_of_funcs = __exported_nifs__.len,
    .funcs = &(__exported_nifs__[0]),
    .load = null,
    .reload = null,
    .upgrade = null,
    .unload = null,
    .vm_variant = "beam.vanilla",
    .options = 1,
    .sizeof_ErlNifResourceTypeInit = @sizeOf(e.ErlNifResourceTypeInit),
    .min_erts = "erts-13.1.2",
};

export fn nif_init() *const e.ErlNifEntry {
    return &entry;
}
